<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[3]</title>
    <url>/2020/02/01/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/26/lets-build-a-simple-interpreter-part-03/" target="_blank" rel="noopener">翻译</a></p>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, MINUX, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;repr(self.value)&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5 + 3", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Lexer code                                             #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Invalid syntax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            value += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="comment"># Parser / Interpreter code                              #</span></span><br><span class="line">    <span class="comment">##########################################################</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return an INTEGER token value."""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Arithmetic expression parser / interpreter."""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        result = self.term()</span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">                result += self.term()</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result -= self.term()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            print()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这一课实现了多个数字的加减操作，思路大致和我想的差不多，不过循环条件是“当前字符是加号或减号”。</p>
<p>引入了句法图的使用和句法分析的概念。</p>
<blockquote>
<p>parser 只是识别出结构并保证它符合某些规范，interpreter 在 parser 成功识别后对表达式进行求值。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>画一张只包含乘除法的算术表达式句法图，例如“7 * 4 / 2 * 3”。不开玩笑，拿只钢笔 或铅笔试试。</p>
<p>和加减法的句法图一样。</p>
</li>
<li><p>修改计算器的源代码使它解释只包含乘除法的算术表达式，如“7 * 4 / 2 * 3”。</p>
<p>把代码里的加减换成乘除就行。</p>
</li>
<li><p>从头写一个可以处理如“7 - 3 + 2 - 1”这样算术表达式的解释器。使用任何你喜欢的语 言都可以，只靠自己，不要参考例子。做这件事时，想想都需要包含的组件：lexer 获取 输入并把它转化为 token 流，parser 从 lexer 提供的 token 流中识别结构， interpreter 在 parser 成功识别到一个合法的算术表达式之后求得其结果。把这些连起 来。花点时间把你学到的知识转化为一个可以运行的算术表达式解释器。</p>
<p>因为我别的语言都不太会，所以决定用C语言。本以为，这是个非常简单的事情，没想到写了两天，我好难过啊T_T</p>
<p>第一天发现根本没法不看python代码直接写，这说明我对整个算法流程都还不熟悉，只知道大概原理，没法自己实现，然后开始照着python代码写。这个过程中还发现我对C语言也不太熟悉，很多东西都记不清了，尤其是字符串数组和指针，实际上我到现在也没搞明白<code>char *str</code>和<code>char str[]</code>什么时候用哪个、怎么用。</p>
<p>第二天，也就是今天（20200202），我决定全用<code>char str[100]</code>这种，但还是有各种各样的问题，不过都渐渐解决了。然后花了一个多小时，才发现最大的问题在于C语言的字符串操作完全不能直接用<code>=</code>之类的方式搞，要用<code>strcpy</code>和<code>strcmp</code>，然后又是一个多小时，才发现我把<code>strcpy(new,old)</code>写成了<code>strcpy(old,new)</code>，然后第三个一小时，发现我上一步有两个用了<code>strcpy</code>的没改过来，还把一个<code>while</code>里的<code>==</code>写成了<code>=</code>。我怕是个傻子吧……</p>
<p>总之，现在写完了，能正常运行出结果。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#define SWAP(a,b) (a)^&#x3D;(b);(b)^&#x3D;(a);(a)^&#x3D;(b)</span><br><span class="line"></span><br><span class="line">char INTEGER[100]&#x3D;&quot;INTEGER&quot;;</span><br><span class="line">char PLUS[100]&#x3D;&quot;PLUS&quot;;</span><br><span class="line">char MINUS[100]&#x3D;&quot;MINUS&quot;;</span><br><span class="line">char END[100]&#x3D;&quot;EOF&quot;;</span><br><span class="line">int i&#x3D;1;</span><br><span class="line"></span><br><span class="line">struct Token		&#x2F;&#x2F;词法单元</span><br><span class="line">&#123;</span><br><span class="line">	char type[100];	&#x2F;&#x2F;类型，可以是integer、plus、minus和end</span><br><span class="line">	char value[100];	&#x2F;&#x2F;值，可以是数字，+，-，eof</span><br><span class="line">&#125;;</span><br><span class="line">struct Intepreter		&#x2F;&#x2F;解释器</span><br><span class="line">&#123;</span><br><span class="line">	int pos;			&#x2F;&#x2F;索引</span><br><span class="line">	char current_char;	&#x2F;&#x2F;当前字符</span><br><span class="line">	char text[100];		&#x2F;&#x2F;输入的字符串</span><br><span class="line">	Token token;		&#x2F;&#x2F;当前词法单元</span><br><span class="line">&#125;;</span><br><span class="line">Intepreter intepreter;</span><br><span class="line">int error()			&#x2F;&#x2F;输错符号的报错</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Invalid syntax&quot;);</span><br><span class="line">	exit(100);</span><br><span class="line">&#125;</span><br><span class="line">Intepreter init(char text[100])	&#x2F;&#x2F;初始化解释器</span><br><span class="line">&#123;</span><br><span class="line">	Token tmp;</span><br><span class="line">	tmp.type[100]&#x3D;&#123;&#125;;</span><br><span class="line">	tmp.value[100]&#x3D;&#123;&#125;;</span><br><span class="line">	Intepreter intepreter;</span><br><span class="line">	strcpy(intepreter.text,text);</span><br><span class="line">	intepreter.pos&#x3D;0;</span><br><span class="line">	intepreter.current_char&#x3D;text[intepreter.pos];</span><br><span class="line">	strcpy(intepreter.token.type,tmp.type);</span><br><span class="line">	strcpy(intepreter.token.value,tmp.value);</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;索引后移一位改变当前字符</span><br><span class="line">Intepreter advance()</span><br><span class="line">&#123;</span><br><span class="line">	intepreter.pos+&#x3D;1;</span><br><span class="line">	if (intepreter.pos&gt;&#x3D;strlen(intepreter.text))</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;&#39;\0&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.current_char&#x3D;intepreter.text[intepreter.pos];</span><br><span class="line">	&#125;</span><br><span class="line">	return intepreter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;跳过空格</span><br><span class="line">void skip_whitespace()</span><br><span class="line">&#123;</span><br><span class="line"> 	while(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        intepreter&#x3D;advance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;&#x2F;返回整数词法单元</span><br><span class="line">int integer()</span><br><span class="line">&#123;</span><br><span class="line"> 	int result&#x3D;0;</span><br><span class="line"> 	while (intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		result&#x3D;result*10+(intepreter.current_char-&#39;0&#39;);</span><br><span class="line"> 		intepreter&#x3D;advance();</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来取词法单元</span><br><span class="line">Token get_next_token()</span><br><span class="line">&#123;</span><br><span class="line">	Token token;</span><br><span class="line">	while(intepreter.current_char!&#x3D;&#39;\0&#39;)</span><br><span class="line">	&#123;</span><br><span class="line">		if(intepreter.current_char&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			skip_whitespace();</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&gt;&#x3D;&#39;0&#39; &amp;&amp; intepreter.current_char&lt;&#x3D;&#39;9&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			strcpy(token.type,INTEGER);</span><br><span class="line">			itoa(integer(),token.value,10);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;+&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,PLUS);</span><br><span class="line">			strcpy(token.value,&quot;+&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(intepreter.current_char&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			intepreter&#x3D;advance();</span><br><span class="line">			strcpy(token.type,MINUS);</span><br><span class="line">			strcpy(token.value,&quot;-&quot;);</span><br><span class="line">			return token;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			error();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	strcpy(token.type,END);</span><br><span class="line">	strcpy(token.value,&quot;EOF&quot;);</span><br><span class="line">	return token;</span><br><span class="line">&#125;</span><br><span class="line">void eat(char type[100])</span><br><span class="line">&#123;</span><br><span class="line">	if (strcmp(intepreter.token.type,type)&#x3D;&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		intepreter.token &#x3D; get_next_token();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; error();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int term()</span><br><span class="line">&#123;</span><br><span class="line">    Token token;</span><br><span class="line">    strcpy(token.type,intepreter.token.type);</span><br><span class="line">    strcpy(token.value,intepreter.token.value);</span><br><span class="line">    eat(INTEGER);</span><br><span class="line">    return atoi(token.value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;用来算表达式</span><br><span class="line">int expr()</span><br><span class="line">&#123;</span><br><span class="line">	int result&#x3D;0;</span><br><span class="line">	Token token;</span><br><span class="line">	intepreter.token&#x3D;get_next_token();</span><br><span class="line">    result&#x3D;term();</span><br><span class="line">    while ((strcmp(intepreter.token.type,PLUS)&#x3D;&#x3D;0)||(strcmp(intepreter.token.type,MINUS)&#x3D;&#x3D;0))</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(token.type,intepreter.token.type);</span><br><span class="line">        strcpy(token.value,intepreter.token.value);</span><br><span class="line">        if (strcmp(token.type,PLUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(PLUS);</span><br><span class="line">            result&#x3D;result+term();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (strcmp(token.type,MINUS)&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            eat(MINUS);</span><br><span class="line">            result-&#x3D;term();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char text[100];</span><br><span class="line">	printf(&quot;calc&gt;&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, &amp;text);</span><br><span class="line">	intepreter&#x3D;init(text);</span><br><span class="line">	int result&#x3D;expr();</span><br><span class="line">	printf(&quot;result is %d\n&quot;,result);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是句法图？</p>
<p><strong>句法图</strong> 就是程序语言句法规则的图形表示。基本上，句法图从视觉上向 你展示了在你的程序语言中哪些语句是允许的哪些是不允许的。</p>
</li>
<li><p>什么是句法分析？</p>
<p>从 token 流中识别组合的过程叫 <strong>parsing</strong>。</p>
</li>
<li><p>什么是句法分析器？</p>
<p>解释器或编译器中执行parsing的部分叫 <strong>parser</strong>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编译原理</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>各种平台遇到过的error处理方式</title>
    <url>/2020/01/31/%E5%90%84%E7%A7%8D%E5%B9%B3%E5%8F%B0%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84error%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ol>
<li><p>平台：visiual studio<br>error LNK2026: 模块对于 SAFESEH 映像是不安全的<br>解决方法：属性 - &gt; 链接器 - &gt; 附加选项输入 /SAFESEH:NO - &gt; 应用</p>
</li>
<li><p>平台：visiual studio<br>error C4996: ‘fopen’: This function or variable may be unsafe. Consider using fopen_sinstead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help   for details.<br>1&gt;f:\program files (x86)\microsoft visual studio 12.0\vc\include\stdio.h(211) : 参见“fopen”的声明<br>解决方法：预处理器加入_CRT_SECURE_NO_WARNINGS</p>
</li>
<li><p>平台：visiual studio<br>error C2664: “int MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT)”: 无法将参数 2 从“const char [17]”转换为“LPCWSTR”<br>解决方法：项目菜单-&gt;属性-&gt;配置属性-&gt;常规-&gt;项目默认值-&gt;字符集从unicode改为未设置</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 _main，该符号在函数 ___tmainCRTStartup 中被引用<br>解决方法：右击项目，打开“属性”页，链接器-&gt;系统-&gt;子系统-&gt;/subsystem:windows。如果是刚开始默认的是/subsystem:windows则改为/subsytem:console</p>
</li>
<li><p>平台：visiual studio<br>error LNK2019: 无法解析的外部符号 <strong>imp</strong>timeGetTime@0，该符号在函数 “void __cdecl TimerInit(void)” (?TimerInit@@YAX<br>解决方法：将winmm.lib打入“附加依赖项”</p>
</li>
<li><p>平台：visiual studio<br>fatal error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏<br>解决方法：右键-&gt;工程属性-&gt;配置属性-&gt; 清单工具-&gt;输入和输出-&gt;嵌入清单，选择[否]</p>
</li>
</ol>
]]></content>
      <categories>
        <category>无分类项</category>
      </categories>
      <tags>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[2]</title>
    <url>/2020/01/31/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part2/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/25/lets-build-a-simple-interpreter-part-02/" target="_blank" rel="noopener">翻译</a></p>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, MINUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: 'INTEGER', 'PLUS', 'MINUS', or 'EOF'</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: non-negative integer value, '+', '-', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of class instance</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">            Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Token(<span class="subst">&#123;self.type&#125;</span>, <span class="subst">&#123;self.value&#125;</span>)'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3 + 5", "12 - 5", etc</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">        self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Advance the 'pos' pointer and set the 'current_char' variable."""</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(self.text):</span><br><span class="line">            self.current_char = <span class="literal">None</span>  <span class="comment"># Indicates end of input</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current_char = self.text[self.pos]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">            self.advance()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a (multidigit) integer consumed from the input."""</span></span><br><span class="line">        result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">            result += self.current_char</span><br><span class="line">            self.advance()</span><br><span class="line">        <span class="keyword">return</span> int(result)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Parser / Interpreter</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER PLUS INTEGER</span></span><br><span class="line"><span class="string">        expr -&gt; INTEGER MINUS INTEGER</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># set current token to the first token from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># we expect the current token to be either a '+' or '-'</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            self.eat(PLUS)</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="comment"># we expect the current token to be an integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token</span></span><br><span class="line">        <span class="comment"># at this point either the INTEGER PLUS INTEGER or</span></span><br><span class="line">        <span class="comment"># the INTEGER MINUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding or subtracting two integers,</span></span><br><span class="line">        <span class="comment"># thus effectively interpreting client input</span></span><br><span class="line">        <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">            result = left.value + right.value</span><br><span class="line">        <span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">            result = left.value - right.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>这个处理方式和我想的不太一样…</p>
<p>整体逻辑是：</p>
<ol>
<li><code>get_next_token</code>是词法分析器，输入一个字符串，逐一输出词法单元，比如输入<code>32 + 5</code>，输出的流应该是<code>Token(INTEGER, 32) -&gt; Token(PLUS, +) -&gt; Token(INTEGER, 5)</code>。<br>这个词法分析器用到的辅助函数为<code>advance()</code>，<code>skip_whitespace()</code>和<code>interger()</code>，其中<code>advance()</code>让索引后移一位，<code>skip_whitespace()</code>跳过空格，<code>interger()</code>把连续的数字变成一个完整的数字。注意这里如果是多位数中间有空格，多位数会被拆成两个数字，比如<code>32 3</code>会被判断为<code>32</code>和<code>3</code>，而不是<code>323</code>。<br>词法分析过程中会遇到以下几种情况：(1)空格，要跳过空格，循环继续运行，分析下一个字符；(2)结束符，直接返回<code>EOF</code>对应的<code>token</code>；(3)数字，循环终止，连后面的几位数字字符一起变成一个数字，返回对应的<code>token</code>；(4)是<code>+</code>或者<code>-</code>，索引移到下一位，循环终止，返回运算符对应的<code>token</code>。<br>分析几个辅助函数：<ol>
<li><code>advance()</code>，索引<code>pos</code>后移一位，当前字符<code>current.char</code>的值变为新索引对应的字符。</li>
<li><code>skip_whitespace()</code>，循环调用<code>advance()</code>直到当前字符不是空格。</li>
<li><code>integer()</code>，先声明一个初始为空字符串的<code>result</code>，然后循环把<code>current.char</code>加到<code>result</code>这个字符串里，接着<code>advance()</code>移动到下一位，直到当前字符不是数字。</li>
</ol>
</li>
<li><code>expr()</code>是用来计算表达式的，判断词法分析后的词法单元是否符合规则，然后根据规则来计算结果。辅助函数为<code>eat()</code>，用来判断当前词法单元是否符合规则。</li>
</ol>
<p>以输入<code>32 + 5</code>为例分析整个流程：</p>
<ol>
<li><p>首先运行的是<code>main()</code>，获取输入字符串，存到<code>text</code>中（<code>line116</code>)，并用<code>text</code>初始化<code>interpreter</code>这个解释器类(<code>line121</code>)，此时，<code>interpreter.text</code>就是我们输入的字符串，<code>interpreter.pos</code>是初始值<code>0</code>，<code>self.current_token</code>是初始值<code>None</code>，<code>self.current_char</code>是<code>interpreter.text</code>这个字符串数组下标为<code>pos=0</code>对应的字符，也就是<code>3</code>。</p>
</li>
<li><p>接下来<code>line122</code>调用了表达式计算器<code>expr()</code>，而<code>expr()</code>的第一行调用了词法分析器<code>get_next_token()</code>，因为字符3是数字，所以要去调用<code>integer()</code>函数，并返回一个类型为<code>INTEGER</code>、值为函数结果的<code>TOKEN</code>。<br>在执行完<code>integer()</code>并返回之前，<code>pos=0</code>，<code>current_token=None</code>，<code>current_char=3</code>。</p>
</li>
<li><p>进入<code>integer()</code>函数，最初<code>result</code>是空字符串，<code>current_char=3</code>符合循环条件，进入<code>while</code>循环，<code>result</code>变成<code>3</code>（是字符串格式）,调用<code>advance()</code>，接下来先让索引后移，即<code>pos=1</code>，此时还没移到最后一位，更新<code>current_char=text[pos]=text[1]=2</code>。此时还符合循环条件，<code>result</code>把新的<code>current_char</code>加上，变成<code>32</code>（字符串格式），再次<code>advance()</code>，调用完后，<code>pos=2</code>，依旧没移到最后一位，<code>current_char=text[2]=空格</code>。这时不满足循环条件了，循环结束，返回字符串<code>result</code>对应的数字也就是32。</p>
</li>
<li><p>然后回到<code>get_next_token()</code>，它已经有返回值了，返回给之前的<code>expr()</code>中的<code>self.current_token</code>，这是我们得到的第一个词法单元，是我们要计算的表达式的左值，将它存到<code>left</code>中，之后可以使用<code>left.value</code>来访问它的值，这之后就调用<code>eat()</code>看该值是不是一个<code>INTEGER</code>，如果是，就再次调用<code>get_next_token()</code>继续分析下一个单元，反之则报错。很显然此时<code>current_token</code>是<code>(INTEGER,32)</code>，符合要求，进入<code>get_next_token()</code>。</p>
</li>
<li><p><code>get_next_token()</code>判断此时<code>current_char</code>是空格，因此执行<code>skip_whitespace()</code>。</p>
</li>
<li><p>在<code>skip_whitespace()</code>中，<code>current_char</code>满足循环条件，进入循环体，调用<code>advance()</code>，<code>pos=3</code>，<code>current_char=text[3]=+</code>，循环结束，回到<code>get_next_token()</code>，执行<code>continue</code>，也就是继续进行词法判断。</p>
</li>
<li><p>由于<code>current_char</code>是<code>+</code>，在对应的<code>if</code>分支中，执行<code>advance()</code>，<code>pos=4</code>,<code>current_char=text[4]=空格</code>，然后把<code>+</code>对应的<code>token</code>返回到<code>expr()</code>中。</p>
</li>
<li><p><code>expr()</code>把新得到的<code>token</code>存入<code>op</code>，并通过<code>eat()</code>判断该<code>token</code>是否是一个加号或者减号。此时是加号，又开始了<code>get_next_token()</code>。</p>
</li>
<li><p>这次<code>get_next_token()</code>首先进入空格分支，跳过空格后，<code>pos=5</code>，<code>current_char=5</code>，进入数字分支，执行<code>integer()</code>。<code>integer()</code>中和第三步一样，最终返回数字5，再回到<code>get_next_token()</code>，返回5对应的<code>token</code>给<code>expr()</code>，存在<code>right</code>中。</p>
</li>
<li><p>此时，我们已经完成了词法分析，得到了<code>(INTEGER, 32) -&gt; (PLUS, &#39;+&#39;) -&gt; (INTEGER, 5)</code>的词法结构。由于<code>OP</code>对应的类型是<code>PLUS</code>，对<code>left.value</code>和<code>right.value</code>执行加法，存入<code>result</code>并返回。</p>
</li>
<li><p>再回到<code>line122</code>，<code>result</code>已经得到了结果，<code>line123</code>输出该结果，程序运行结束。</p>
</li>
</ol>
<p>也就是说，在计算表达式结果的函数中调用词法分析器，判断词法分析的结果是否符合规则，如果符合规则，就按规则继续运行。在计算器函数中，只会出现<code>token</code>类型的变量，而词法分析函数会负责把词法单元打包成<code>token</code>交给计算器。</p>
<blockquote>
<p>在解释一个表达式之前，你需要知道它是哪种组合，比如相加或相减。这是 <code>expr</code> 方法本质上做的事： 它从 <code>get_next_token</code> 方法得到的 token 流中找到结构，然后解释它识别出的组合，产 生算术表达式的结果。<br>从 token 流中查找结构，或者说从 token 流中识别组合，的过程叫做 <strong>parsing</strong>. 解释器 或编译器中执行这部分任务的叫 <strong>parser</strong>.<br>现在你知道解释器的 <strong>parsing</strong> 和 <strong>解释</strong> 都在 <code>expr</code> 方法中了── <code>expr</code> 方法首先尝 试从 token 流中识别（即parse） INTEGER -&gt; PLUS -&gt; INTEGER 或 the INTEGER -&gt; MINUS -&gt; INTEGER 组合，在成功识别到（即parsed）其中一个组合时，该方法就解释执行 它并返回给调用者两个整数相加或相减的结果。</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>扩展计算器以处理两个整数相乘</p>
</li>
<li><p>扩展计算器以处理两个整数相除</p>
<p>前两个都很简单，仿照加法减法的代码复制改写就行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运算符声明</span></span><br><span class="line">INTEGER, PLUS, MINUS, MULTIPLY, DIVIDE, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'MINUS'</span>, <span class="string">'MULTIPLY'</span>, <span class="string">'DIVIDE'</span>, <span class="string">'EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(MULTIPLY, <span class="string">'*'</span>)</span><br><span class="line"><span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">	self.advance()</span><br><span class="line">	<span class="keyword">return</span> Token(DIVIDE, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># expr()</span></span><br><span class="line"><span class="comment"># 修改读取运算符</span></span><br><span class="line">op = self.current_token</span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	self.eat(PLUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	self.eat(MINUS)</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	self.eat(MULTIPLY)</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	self.eat(DIVIDE)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改计算结果那里</span></span><br><span class="line"><span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">	result = left.value + right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">	result = left.value - right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == MULTIPLY:</span><br><span class="line">	result = left.value * right.value</span><br><span class="line"><span class="keyword">elif</span> op.type == DIVIDE:</span><br><span class="line">	result = left.value / right.value</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	self.error()</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改代码以使它可以解释包含任意个数字的加减操作，如“9 - 5 + 3 + 11”</p>
<p>这个也不难。此时的词法结构是<code>INTEGER -&gt; 循环[OP -&gt;INTEGER]</code>，在<code>expr()</code>里首先读取并<code>eat()</code>第一个词法单元，<code>result</code>先等于这个单元的值，接下来用<code>while</code>进行两个词法单元为一组的循环，直到读取到<code>EOF</code>，每个循环里，<code>result</code>与新的<code>INTEGER</code>进行加减运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">result = left.value</span><br><span class="line"><span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	op = self.current_token</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		self.eat(PLUS)</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		self.eat(MINUS)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br><span class="line">	right = self.current_token</span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line">	<span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">		result += right.value</span><br><span class="line">	<span class="keyword">elif</span> op.type == MINUS:</span><br><span class="line">		result -= right.value</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		self.error()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是 lexeme？<br>lexeme 是组成 token 的一个字符序列。（这个词翻译过来是<strong>词位</strong>或<strong>词素</strong>）<br><code>token</code>和<code>lexeme</code>的关系类似于类和实例（或者对象）之间的关系。举例来说，变量<code>a</code>和<code>b</code>，它们属于同一种<code>token</code>：<code>identifier</code>，而<code>a</code>的<code>lexeme</code>是<code>a</code>，<code>b</code>的<code>lexeme</code>是<code>b</code>。每个关键字是一种<code>token</code>。<code>token</code>可以附带一个值属性，例如变量<code>a</code>，调用<code>gettoken()</code>时，会返回一个<code>identifier</code>类型的<code>token</code>，其值属性是<code>a</code>。</p>
</li>
<li><p>在 token 流中找到结构的过程叫什么？或者这么问，在 token 流中识别出特定组合的过程叫什么？<br>parsing（翻译是语法分析或句法分析）</p>
</li>
<li><p>解释器（编译器）做 parsing 工作的部分叫什么？<br>parser（也就是语法分析器）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编译原理</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s Build A Simple Interpreter笔记[1]</title>
    <url>/2020/01/30/Let-s-Build-A-Simple-Interpreter%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h2 id="课程文档"><a href="#课程文档" class="headerlink" title="课程文档"></a>课程文档</h2><p><a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener">原文</a></p>
<p><a href="https://feng-qi.github.io/2018/01/23/lets-build-a-simple-interpreter-part-01/" target="_blank" rel="noopener">翻译</a></p>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Token types</span></span><br><span class="line"><span class="comment"># EOF (end-of-file) token is used to indicate that</span></span><br><span class="line"><span class="comment"># there is no more input left for lexical analysis</span></span><br><span class="line">INTEGER, PLUS, EOF = <span class="string">'INTEGER'</span>, <span class="string">'PLUS'</span>, <span class="string">'EOF'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type, value)</span>:</span></span><br><span class="line">        <span class="comment"># token type: INTEGER, PLUS, or EOF</span></span><br><span class="line">        self.type = type</span><br><span class="line">        <span class="comment"># token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""String representation of the class instance.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">        Token(INTEGER, 3)</span></span><br><span class="line"><span class="string">        Token(PLUS, '+')</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token(&#123;type&#125;, &#123;value&#125;)'</span>.format(</span><br><span class="line">            type=self.type,</span><br><span class="line">            value=repr(self.value)</span><br><span class="line">        )    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        <span class="comment"># client string input, e.g. "3+5"</span></span><br><span class="line">        self.text = text</span><br><span class="line">        <span class="comment"># self.pos is an index into self.text</span></span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        <span class="comment"># current token instance</span></span><br><span class="line">        self.current_token = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Error parsing input'</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Lexical analyzer (also known as scanner or tokenizer)</span></span><br><span class="line"><span class="string">        This method is responsible for breaking a sentence</span></span><br><span class="line"><span class="string">        apart into tokens. One token at a time.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        text = self.text    </span><br><span class="line">        <span class="comment"># is self.pos index past the end of the self.text ?</span></span><br><span class="line">        <span class="comment"># if so, then return EOF token because there no more</span></span><br><span class="line">        <span class="comment"># input left to convert into tokens</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt; len(text) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)    </span><br><span class="line">        <span class="comment"># get a character at the position self.pos and decide</span></span><br><span class="line">        <span class="comment"># what token to create based on the single character</span></span><br><span class="line">        current_char = text[self.pos]    </span><br><span class="line">        <span class="comment"># if the character is a digit then convert it to</span></span><br><span class="line">        <span class="comment"># integer, create an INTEGER token, increment self.pos</span></span><br><span class="line">        <span class="comment"># index to point to the next character after the digit,</span></span><br><span class="line">        <span class="comment"># and return the INTEGER token</span></span><br><span class="line">        <span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">            token = Token(INTEGER, int(current_char))</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        <span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">            token = Token(PLUS, current_char)</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token    </span><br><span class="line">        self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="comment"># compare the current token type with the passed token</span></span><br><span class="line">        <span class="comment"># type and if they match then "eat" the current token</span></span><br><span class="line">        <span class="comment"># and assign the next token to the self.current_token,</span></span><br><span class="line">        <span class="comment"># otherwise raise an exception.</span></span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.error()    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""expr -&gt; INTEGER PLUS INTEGER"""</span></span><br><span class="line">        <span class="comment"># set current token to the first token taken from the input</span></span><br><span class="line">        self.current_token = self.get_next_token()    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a '+' token</span></span><br><span class="line">        op = self.current_token</span><br><span class="line">        self.eat(PLUS)    </span><br><span class="line">        <span class="comment"># we expect the current token to be a single-digit integer</span></span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="comment"># after the above call the self.current_token is set to</span></span><br><span class="line">        <span class="comment"># EOF token    </span></span><br><span class="line">        <span class="comment"># at this point INTEGER PLUS INTEGER sequence of tokens</span></span><br><span class="line">        <span class="comment"># has been successfully found and the method can just</span></span><br><span class="line">        <span class="comment"># return the result of adding two integers, thus</span></span><br><span class="line">        <span class="comment"># effectively interpreting client input</span></span><br><span class="line">        result = left.value + right.value</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># To run under Python3 replace 'raw_input' call with 'input'</span></span><br><span class="line">            text = input(<span class="string">'calc&gt; '</span>)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        interpreter = Interpreter(text)</span><br><span class="line">        result = interpreter.expr()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>




<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ol>
<li>词法分析(lexical analysis)：把输入字符串拆分成 token 的过程。解释器中做这个工作的部分被称为 <strong>词法分析器</strong>(lexical analyzer)，简称 <strong>lexer</strong> ，也被称作  <strong>scanner</strong> 或 <strong>tokenizer</strong> 。</li>
<li>在完成词法分析后，解释器需要验证token序列是否符合期望的序列，如果符合，则进行一些运算，不符合则抛出异常。</li>
</ol>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ol>
<li>目的是执行一位数的加法运算，整体逻辑是，先取第一个字符，判断是否是数字，如果是，就把这个数字存在<code>left</code>中，然后取第二个字符，判读是否为加号，如果是，再继续取第三个字符，判断是否为数字并把数字存在<code>right</code>中，接下来就可以计算<code>left.value + right.value</code>了。整个过程中字符的移动依靠一个名为<code>pos</code>的变量，它作为索引，每当取完一个字符，<code>pos</code>的值就会<code>+1</code>，这样直到最后一个字符。</li>
<li><code>Token</code>类构造了一个结构为<code>(类型, 值)</code>的变量，当我们访问某个<code>Token</code>类型的变量<code>v</code>时，可以通过<code>v.type</code>来获取它的类型，通过<code>v.value</code>获取它的值。</li>
<li><code>Interpreter</code>类是我们的解释器类型，其中<code>get_next_token()</code>函数可以从字符串中取一个字符，判断该字符类型是数字还是<code>+</code>，并返回正确的<code>Token</code>结构，比如是数字，就返回<code>Token(INTEGER, int(current_char))</code>，然后索引(<code>pos</code>)往后挪一位，如果既不是数字也不是加号，比如是空格，就会报错，如果已经到最后一位了，会返回<code>EOF</code>。</li>
<li>接下来的<code>eat()</code>函数，参数是判断现在取出来的字符<code>type</code>是否符合设想的<code>type</code>，如果符合，就调用<code>get_next_token()</code>取下一个字符；反之，就输出错误信息。</li>
<li>然后<code>expr()</code>函数用来按顺序从头到尾逐个读取字符，在<code>eat()</code>的帮助下判断整体结构是否符合词法要求（比如这里的要求是<code>INTEGER -&gt; + INTEGER</code>）并执行运算。</li>
<li>最后的<code>main()</code>，将输入的字符串存到<code>text</code>中，并用<code>text</code>初始化类型为<code>Interpreter</code>的变量<code>interpreter</code>，接下来调用<code>interpreter.expr()</code>进行计算，结果存放到<code>result</code>中并输出。</li>
</ol>
<h4 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h4><ol>
<li><p>python命名规则：以下划线开头的标识符是有特殊意义的。以单下划线开头例如<code>_foo</code> 代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from xxx import</code> 而导入。<br> 以双下划线开头的 <code>__foo</code> 代表类的私有成员，以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里特殊方法专用的标识，如 <code>__init__()</code> 代表类的构造函数。</p>
</li>
<li><p>python中的<code>main()</code>函数：python程序按顺序执行，而不是像之前学过的语言那样先找<code>main()</code>然后从<code>main()</code>开始，执行过程中遇到<code>def</code>代码块会先跳过，每个代码块需要保持相同的缩进。</p>
<p> 例如：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code1</span></span><br><span class="line">print(<span class="string">"test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    str = <span class="string">"function"</span></span><br><span class="line">    print(str)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"main"</span>)</span><br><span class="line">    foo()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">test</span><br><span class="line">main</span><br><span class="line">function</span><br><span class="line"></span><br><span class="line"><span class="comment"># code2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"in func_print"</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">        print(<span class="string">"In main"</span>)    </span><br><span class="line">    main()  </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"></span><br><span class="line"><span class="comment"># code3</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">        func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello python !!!</span><br><span class="line">In main</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line"></span><br><span class="line"><span class="comment">#code4</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Hello python !!!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_print</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in func_print"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"In main"</span>)</span><br><span class="line"></span><br><span class="line">	func_print()</span><br><span class="line">main()</span><br><span class="line"><span class="comment"># output </span></span><br><span class="line">Hello python !!!</span><br><span class="line"><span class="keyword">in</span> func_print</span><br><span class="line">In main</span><br></pre></td></tr></table></figure>
</li>
<li><p>python中的<code>__name__</code>：<code>__name__</code>是python的一个内置类属性，它天生就存在于一个 python 程序中，代表对应程序名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test()</span><br><span class="line">	print(__name__)</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p>直接运行temp2.py 时：<code>__name__=&quot;__main__&quot;</code>，在其它程序中导入temp2.py，则：<code>__name__=&quot;temp2.py&quot;</code>，所以<code>__name__</code>的主要作用就是用来区分，模块是直接被运行还是被导入。</p>
<p>实际使用时，我们会把测试模块时要执行的语句放到<code>if __name__ == &#39;__main__&#39;:</code>这个代码块里，这样测试的时候能看到测试结果，而调用的时候，测试语句不会被执行，也就不用删除测试语句。</p>
</li>
</ol>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>修改代码使得允许输入多位整数，例如<code>12+3</code></p>
<p>多位数不一定是几位数，也就是说我们在得到输入之前无法判断整个字符串第几位是什么类型，但是整体结构一定是<code>连在一起的数字 + 连在一起的数字</code>，因此考虑用<code>while</code>循环读取数字，在当前字符不是数字的情况下跳出循环去读取<code>+</code>，然后继续循环读数字，直到读取出<code>EOF</code>，字符串结束。具体来说是声明<code>left</code>和<code>right</code>两个数字并初始化为0，然后<code>left</code>存第一位数字，接下来乘10+第二位数字，再乘10+第三位数字，依次循环；<code>right</code>也是这样。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line">left = right = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type == <span class="string">'INTEGER'</span>:    </span><br><span class="line">	left = left * <span class="number">10</span> + self.current_token.value    </span><br><span class="line">	self.eat(INTEGER)</span><br><span class="line"><span class="comment"># 中间几行代码省略</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.type != <span class="string">'EOF'</span>:</span><br><span class="line">	right = right * <span class="number">10</span> + self.current_token.value</span><br><span class="line">	self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加一个跳过空白符的方法，使你的计算器可以处理包含空白符的输入如<code>12 + 3</code></p>
<p>我们要增加一个<code>Token</code>类型用来识别空格，然后在<code>expr()</code>中读取到空格时就调用<code>eat()</code>来跳过，我们假设空格不会出现在一个多位数的中间（比如<code>1 2 3</code>就会报错)。</p>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在代码开始的地方加</span></span><br><span class="line">SPACE = <span class="string">'SPACE'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在get_next_token()里加</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">' '</span>:</span><br><span class="line">	token = Token(SPACE, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在expr()的数字和操作符的前后加</span></span><br><span class="line"><span class="keyword">while</span> self.current_token.value == <span class="string">' '</span>:</span><br><span class="line">	self.eat(SPACE)</span><br></pre></td></tr></table></figure>

<p><strong>这里存在一些问题需要改进</strong>：</p>
<ol>
<li>应该可以想办法跳过多位数中间的空格，也就是直接忽略所有空格；</li>
<li>个人认为不应该在<code>expr()</code>这个函数中出现对字符类型的判断，应该是在<code>expr()</code>中逐位后移，这个过程中调用其他函数来处理忽略空格等情况，也就是说上一个的<code>while</code>循环也不太合适，但是我暂时没想到怎么改，就先这样吧，反正功能上没问题。之后学到正则相关的地方可能会有新的思路。</li>
</ol>
</li>
<li><p>修改代码使得它可以处理<code>-</code>而非<code>+</code>的情况</p>
<p>这个类似于空格，也是要添加一下，我的做法是直接把<code>+</code>和<code>-</code>统一成类型为<code>OP</code>值为对应字符的<code>TOKEN</code>，然后在<code>expr()</code>中最后运算的时候，判断该变量的值是什么，再执行对应的运算。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件开头的PLUS = 'PLUS'修改为</span></span><br><span class="line">OP = <span class="string">'OP'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改get_next_token()</span></span><br><span class="line"><span class="keyword">if</span> current_char == <span class="string">'+'</span> <span class="keyword">or</span> current_char == <span class="string">'-'</span>:</span><br><span class="line">	token = Token(OP, current_char)</span><br><span class="line">	self.pos += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改expr()</span></span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'+'</span>:</span><br><span class="line">	result = left + right</span><br><span class="line"><span class="keyword">if</span> op.value == <span class="string">'-'</span>:</span><br><span class="line">	result = left - right</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   <strong>下一课的内容说明了我的想法全是错的…暴风哭泣</strong></p>
<h2 id="检查理解"><a href="#检查理解" class="headerlink" title="检查理解"></a>检查理解</h2><ol>
<li><p>什么是解释器？</p>
<p>解释器把高级语言逐行转译执行。</p>
</li>
<li><p>什么是编译器？</p>
<p>编译器把高级语言翻译成低级语言，再一起执行。</p>
</li>
<li><p>解释器和编译器的区别是什么？</p>
<p>一个是一边翻译一边执行，一个是翻译完再执行。</p>
</li>
<li><p>什么是 token？</p>
<p>有类型的值的对象</p>
</li>
<li><p>将输入拆分成 token 的过程叫什么？</p>
<p>词法分析</p>
</li>
<li><p>解释器中做词法分析的部分叫什么？</p>
<p>词法分析器(lexical analyzer)</p>
</li>
<li><p>解释器或编译器的这个部分还有什么其他常见的名字？</p>
<p>scanner 或 tokenizer</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Let&#39;s Build A Simple Interpreter</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编译原理</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + next + github配置blog</title>
    <url>/2020/01/30/hexo-next-github%E9%85%8D%E7%BD%AEblog/</url>
    <content><![CDATA[<h2 id="安装各种东西"><a href="#安装各种东西" class="headerlink" title="安装各种东西"></a>安装各种东西</h2><ol>
<li>node.js：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网链接</a> 点击下载安装即可。</li>
<li>Git： <a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">Git官网链接</a> 点击下载安装即可。</li>
<li>deployer-git： 命令行里输入<code>npm install hexo-deployer-git --save</code>。</li>
<li>Hexo：<ol>
<li>准备好一个用于存放博客文件的文件夹（比如Github），在该文件夹的根目录下运行刚才装完git以后会出现的git-bash.exe（这里其实直接用cmd进入命令行然后进入博客文件夹也可以）；</li>
<li>输入命令<code>npm install -g hexo-cli</code></li>
</ol>
</li>
</ol>
<a id="more"></a>

<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ol>
<li>创建Hexo工程：接着刚才那个命令输入<code>hexo init blog</code>，这里会在这个文件夹下新建一个blog文件夹，如果把blog换成其他名字也是可以的。</li>
<li>新建Post：命令行里进入blog文件夹（<code>cd blog</code>），输入<code>hexo new “HelloWorld”</code>，这里会在 <strong>/blog/sources/_post/</strong> 目录下生成 <strong>HelloWorld.md</strong> 文件，可以进去打开编辑内容，在之后想写新博客也是通过这个命令生成文件，或者直接把写好的博客文件放到该目录下。</li>
<li>生成静态文件：命令行里输入<code>hexo generate</code>，也可以简单地写成<code>hexo g</code>。这样就使用 <strong>Hexo</strong> 引擎将 <strong>Markdown</strong> 格式的文件解析成可以使用浏览器查看的 <strong>HTML</strong> 文件，<strong>HTML</strong> 文件存储在 <strong>blog/public</strong> 目录下。</li>
<li>运行Hexo服务器：命令行里输入<code>hexo server</code>，也可以简写成<code>hexo s</code>。这时命令行会有一些提示，其中有个地址，一般是<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，在浏览器里打开这个地址，就能看到博客网站是什么样的了。不过这个时候还只是一个本地博客。</li>
</ol>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p><strong>Hexo</strong> 提供了默认主题 <strong>landscape</strong>，主题的位置在 <strong>blog -&gt;themes</strong> 文件夹下。主题根据自己喜好可以在网上找到，通过 <strong>Git</strong> 进行相应的下载。接下来以Next主题为例。</p>
<ol>
<li>还是在blog文件夹下，命令行里输入<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>，这里是用<code>git clone</code>把<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next主题</a>下载并存放到themes -&gt; next 文件夹里。需要注意的是，<code>git clone</code>这个命令下载起来特别慢，但浏览器直接去github下载的话速度还行，所以也可以直接下载解压改文件夹的名字并放到对应的地方。</li>
<li>修改 <strong>/blog/config.yml</strong> 文件，将其中的 <strong>theme</strong> 改成 <strong>next</strong>。如果文件夹的名字不是next，或者用了其他主题等，这里的theme改成对应的文件夹名字就行。</li>
<li>接下来可以输入<code>hexo g</code> 和<code>hexo s</code>来查看新的本地博客。</li>
</ol>
<h2 id="建立Github博客"><a href="#建立Github博客" class="headerlink" title="建立Github博客"></a>建立Github博客</h2><ol>
<li><p>在<a href="https://github.com/" target="_blank" rel="noopener">Github官网</a>注册账号并登陆，点首页右上角的加号新建一个仓库(Repository)，仓库的名字为用户名.github.io（比如我的是kun-bin.github.io），这里一定要是这个格式，不然之后没法直接访问博客网站。然后其他的都是默认内容，点create repository就可以了。如果仓库名字输入错了，之后可以在github上这个仓库页面的setting选项中修改。</p>
</li>
<li><p>打开 <strong>/blog/config.yml</strong>文件修改deploy 属性(注意“：”之后有空格 ) 否则配置失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;kun-bin&#x2F;kun-bin.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>注意这里repository要替换成自己的仓库地址。</p>
</li>
<li><p>初始化本地仓库：在blog文件夹下的命令行输入<code>git init</code></p>
</li>
<li><p>连接远程仓库：命令行接着输入<code>git remote add origin https://github.com/kun-bin/kun-bin.github.io.git</code>，这里记得把地址改成自己的仓库地址，第一次的时候会要求输入github的账号密码。</p>
</li>
<li><p>发布博客页面：命令行里输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，这等于一次性执行了清空、刷新、部署三个命令，此时在浏览器里已经可以通过<code>用户名.github.io</code>访问博客了，在github的这个仓库里也能看到<strong>/blog/public</strong>文件夹里的内容。</p>
</li>
<li><p>可选：<code>hexo d</code>只是把public文件夹中的内容（也就是静态网页）传到了github的仓库里，应该还可以建立分支把博客配置文件整个传到github上，不过我没做这一步。</p>
</li>
</ol>
<h2 id="关于next主题的配置"><a href="#关于next主题的配置" class="headerlink" title="关于next主题的配置"></a>关于next主题的配置</h2><p>目前在blog文件夹里有一个config.yml文件，我们称之为站点配置文件；而在themes/next文件夹里也有一个config.yml文件，称之为主题配置文件。</p>
<ol>
<li><p>基本信息：打开站点配置文件，找到site模块，可以修改博客标题、作者、描述、语言等等信息，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>
</li>
<li><p>菜单配置：初始网页只有两个菜单：home和archive，可以打开主题配置文件，找到menu模块，把需要的菜单前面的#删了，并注意把||<strong>前面</strong>的空格删了，不然可能会点了菜单以后报错（类似Cannot GET /tags/%20/这样的错）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home                          <span class="comment">//首页</span></span><br><span class="line">  archives: /archives/|| archive          <span class="comment">//归档</span></span><br><span class="line">  categories: /categories/|| th           <span class="comment">//分类</span></span><br><span class="line">  tags: /tags/|| tags                     <span class="comment">//标签</span></span><br><span class="line">  about: /about/|| user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/|| calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml|| sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/|| heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure>
<p>这里||后面的单词是指菜单对应的图标，可以自己修改。此外，日程表那个模块，因为实际上调用的是谷歌日历，国内显然没法用，所以不建议使用。</p>
</li>
<li><p>建立菜单对应的页面：还是在blog文件夹下打开命令行，输入<code>hexo new page &quot;categories&quot;</code>，然后在~/blog/source 文件夹中即可看到categories文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2020-01-30 08:54:26</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>tags页面也是一样的方式来建立。</p>
</li>
<li><p>主题风格：一共有四个风格可以选择，打开主题配置文件 找到<code>Scheme Settings</code>，把想用的风格前面的#去掉，比如我这里用了Mist。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>侧栏设置：侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等，打开主题配置文件 找到<code>sidebar</code>，按自己的喜好选择，把想要的那一项的#去掉或者false改成true即可。</p>
</li>
<li><p>头像设置：主题配置文件找到<code>avatar</code>，修改avatar后面的路径为自己头像的路径，头像文件要放到<code>themes/next/source/images</code>中，比如头像文件名为<code>header.jpg</code>，就把那一行写成<code>avatar: /images/header.jpg</code>。如果前面有#就去掉#。</p>
</li>
<li><p>添加搜索：</p>
<ol>
<li><p>还是blog文件夹的命令行里，输入<code>npm install hexo-generator-searchdb --save</code>。</p>
</li>
<li><p>打开站点配置文件找到<code>Extensions</code>在下面添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开主题配置文件找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code>。</p>
</li>
</ol>
</li>
<li><p>还有很多能配置的，比如侧边栏头像下面有github链接，点击页面出现爱心符号，博客背景动态变化等，可自行搜索。</p>
</li>
</ol>
<h2 id="如何发布新的博客"><a href="#如何发布新的博客" class="headerlink" title="如何发布新的博客"></a>如何发布新的博客</h2><ol>
<li><p>在blog文件夹的命令行里输入<code>hexo new &quot;标题&quot;</code>，然后进入<strong>/blog/sources/_post/</strong>找到对应的markdown文件就可以开始写了，也可以直接在这个文件夹下新建一个markdown文件，然后添加对应的文件头。写博客的时候根据需求在文件头里填写tags和categories的信息，然后hexo会自动建立好tags和categories的内容并给文章分类。</p>
<p>文件头信息如下编写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>写好以后保存，然后还是blog文件夹的命令行，输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，就发布成功了。</p>
</li>
<li><p>如果一个文章想设置多个标签，那么在编写文件头信息的时候，要按下面的方式写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags；</span><br><span class="line">	- tag1</span><br><span class="line">	- tag2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>这里<code>tags:</code> 后面一定要换行，下面的<code>-</code>后面注意有空格。</p>
</li>
</ol>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://segmentfault.com/a/1190000018761324" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018761324</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>
]]></content>
      <categories>
        <category>博客配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
